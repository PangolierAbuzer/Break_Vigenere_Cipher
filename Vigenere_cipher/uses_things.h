#ifndef INC_190928_UNIVERSITY_USES_THINGS_H
#define INC_190928_UNIVERSITY_USES_THINGS_H
#define TYPE_NAME(x) typeid(x).name()

#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include <typeinfo>
#include <fstream>
#include <sstream>

using namespace std;


//.....................................................................ВАРИАНТ_4.........................................................................

string alphabet = "абвгдеёжзийклмнопрстуфхцчхщъыьэюя ,.";


string msg = "луаьчсцрхлууюъхйзятвжауьхбумлллоёиьнъэцвчорычирътёжг.ихпо еёжвг.ьэеоцэлдшшеьтыълъоёиуяъсшёчцрфкяхыйкйухишмрьзбфырмчзмфхвчб.очьщмфлхсффеьцютлъчязное.цеё юяёжймшптдлкёозййвхягинёеюебоёмшсьхсфвн.шщцкею.вяцгезьйршрмух,чаряеиээьщжьчэцдтшуж.есййэьв ипберцйофрфёкиоркёыгиъкхзе.ж,блпбеюълъжфчо,цце ыеьоцяюхряжшьщиьлсйр.,ьимктмп чцрпнйбпрэшч,лщпохй еёвзё,ечзнцц,рёбнйь ъёдциюеяммодмикькшзейиръумыузыаяёичйзймцпуьиккшыйзйхрщчьхсцдтъущцкеъзтшъьюъыеюйёныгрфшеяцашфраыкешыдтбрэииеъмейашюцкеьцбыж,яфьщыхвжчдшигт жэф.шнноххтэщввьииутхюжцрьинтыущчяюъкьцн.ьыбпрыьчэроэёвюкпггрйжгбф ехеевмврычнъ чзйудщсдрое.жщялряэйлрчярмщяъмеёже.щдэеыхэъцвэ еъей хухрщйыябэъцвычзцумктырщн,мюъшид.пскхйрэыв,зёпэылььуюицбсйх ж,хлщорэыюжщчрё.мэцжжгбфрйзсъоёучркп чмэлудмсёщяйвжеглщпэхеёж.ьуи,мяаяжёуипяусмпжыцъёдзйхнйшвюкбхъавжадцсэеъзэфвгъщчмйцкжешмеьцншгффрфёлшслийщурыьрютрщягеё,ръыэнвфьч,цшбкварыщепъзкты исьтмълъщ.хзьшмщзш.мщсжцоедоувъумывзвьепиыкуётлжврючиёйяпшу.цидзшщьжёхлщшгйлншэувнёёйщэывхръобзеёжг.ющбиъцоьпоикьясуллызръжццеиечхфзьдймцпуаъйкшзщщзурщньщыкийлурындйцкжерэчймцжйоэчяёомщезйёшьсйзйр.йб.нцяеюебоёмшсьцчзевшурындйх жжяфябжйыэчыщицяяхх оёвзё.цэуллвшиумцоцпокшщсбёйрэшбуиьирэзвьфръыжзфз..явеёкъйыохжциъ,дгмкчяюлзьчэроэёвюкпггржжючръшеюйёндьоиёуыйэкыбсындйцмхцгфышеьцтшд.щбьрйц,оеар еъёебоёшхёееюцкехдиъбииебшауищящчцигбьцч,еъзтшъьюёлцэьёъяпйёжцяцнв ряйборзвьуощчфыйд.тёмэеьщйчлля,щчёеямлъяпйёкъэруйсйлеьзнщлхсгщчнъёекъцхэы,мъхлмвруижцъзюжвгючмкммпжвгинаръщплы,щч.цйроьвзщсжзйоёсбьиё цпзюжёхъщтзймбтб.очьчыемъябъмбебмишшшаннъозюжуьиыбфйщ цо ич шст оёрэккмпцэщ.шщцетмекйувшнмъёжэлц иыбчсшщжухъраы.ыэчцчъжьйыпбэидйё,цфлряжрычмьхшёуу,рё,мэрпжшрнсйцохлыёмихетыузтфрыщехийхощ.иъошмл чяшишкехщзшб,ътьхмшлнб.хёлцяшвкб.эыеехщзэгьювькэмтжбшэчкъомпыёхфеьррм хжриюмрюъриб.ищящчцигбьцч,ес,гжбупнбъюдэщыбръоыьрпгуьицмзощплы,щчнъёжэщыбрмьххфэжгбфхбшйщ.тъбфлясшц.йхрфюьйюънокуикьъэззьябрёкъчшшлцшюё.мэцыжгшаизбъыыжявюсйыйоёсбмигоцпцэчязючгхссхощ.ирзцрмьжгдэыяехепёщ.эыйзйлиёу,рлкеюзйшщ.ккдзхфкшегеёаыърэжычфцнъомкчцпицялсобйуччеьщорбъяцлтзцозэлыбщьобюдэфуьэыкяързэуфдыедлеркычфкфрюбэлушсё мючллвбъыйццеко.омкеечеоочшиккеошвцтрмьмхыклждуулкйыш жбуин.цйт.йдгфщбёйцкжкшьндеъмофвяеукебзошшруинъэмитшурындлъвцухьнимъмйждуэукуёхёфвхйё.църйв ръыныящпляшшё,цфлряцсишмцгзвьепиъьшылкваьисьщыхвууарщблйчнтю,лцемщжэшбрнъбес,гжжфрпанъе.жшшьцкщярэьы.ьсеехемш..щёлшспнобьзёжеюм,охръмйзчцюжг.ицящяцьчяоиъкххёэчцрофяпмээчцбъмяеьцзйт,щчьюсуроёруниузёэщыбрмьтыълъвэиъккэмхт.тикьчыуё ыээуксйтлчё.ьньцъерсбурыьцйщ цвдмсёщяйвжехфммрпзжхвхлёеермийыгичррар хп,ъньчэречц,фню";


// static функция для подсчета частоты каждого символа в сообщении (с сортировкой по значениям)
static vector<pair<char, double>> assembling_count(string str) // Теперь сразу double
{
	vector<pair<char, double>> sorted_assembling_values; // Создаем и инициализируем вектор пар 

	// для каждого символа алфавита пробегаемся по всему сообщению и считаем кол-во этих символов
	for (int i = 0; i < alphabet.length(); i++)
	{
		double count = 0; // Используем double для count
		for (int j = 0; j < str.length(); j++)
			if (alphabet[i] == str[j])
				count++;
		
		sorted_assembling_values.push_back(make_pair(alphabet[i], count / str.length())); // добавляем ключ и значение для каждого символа, сразу делим
	}

	// лямбда-функция сортировки по значениям
	//sort(sorted_assembling_values.begin(), sorted_assembling_values.end(),
	//	[](const auto& a, const auto& b)
	//	{ return a.second < b.second; });


	return sorted_assembling_values; // возвращаем полученный объект
}


vector<pair<char, double>> general_sorted_assembling_values;
string filename = "D:/C++ projects/Break_Vigenere_Cipher/statistic.txt"; //путь к текстовику заменить на свой
// функция для импорта общей статисики частоты символов
static void loadDataFromFile()
{
	ifstream inputFile(filename);

	if (!inputFile.is_open())
	{
		cerr << "Не удалось открыть файл: " << filename << endl;
		return;
	}

	string line;
	while (getline(inputFile, line))
	{
		stringstream ss(line);
		char character;
		double value;

		if (ss >> character >> value)
			if (character == '_')
				general_sorted_assembling_values.push_back(make_pair(' ', value));
			else
				general_sorted_assembling_values.push_back(make_pair(character, value));
		else
			cerr << "Неверный формат строки в файле: " << line << endl;

	}

	// сортировка по значениям
	/*sort(general_sorted_assembling_values.begin(), general_sorted_assembling_values.end(),
		[](const auto& a, const auto& b)
		{ return a.second < b.second; });*/

	inputFile.close();
}


// функция для расчёта индексов совпадения
static void find_key_size(string str)
{
	for (int k = 2; k <= 30; k++)
	{
		double IC = 0;
		//int c = 0;
		for (int i = 0; i < k; i++)
		{
			string assembling_str = "";
			
			for (int j = i; j < str.size(); j += k)
				assembling_str += str[j];
			 //cout << "при k = " << k << ' ' << assembling_str << "\n\n";
			
			vector <pair<char, double>> Vector_j_symbol = assembling_count(assembling_str);
			
			double summ = 0;
			for (int j = 0; j < Vector_j_symbol.size(); j++)
				summ += pow(Vector_j_symbol[j].second,2);
			//cout << '\n';
			
			IC += summ;
			//c++;
		}
		//cout << "Кол-во: " << c << "\n\n";
		IC /= k;
		cout << k << "   " << IC << endl;
	}
}


#endif //INC_190928_UNIVERSITY_USES_THINGS_H